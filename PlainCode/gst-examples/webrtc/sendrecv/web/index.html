<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <style>
      .error {
        color: red;
      }
    </style>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script>
      // Set this to override the automatic detection in websocketServerConnect()
      var ws_protocol = null // use default 'ws'
      var ws_server = null // use default '127.0.0.1'
      var ws_port = null // use default 8443
      // Set this to use a specific peer id instead of a random one
      var default_peer_id = 1
      // Override with your own STUN servers if you want
      var rtc_configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
      // The default constraints that will be attempted. Can be overriden by the user.
      var default_constraints = { video: true, audio: true }

      var connect_attempts = 0
      var peer_connection = new RTCPeerConnection(rtc_configuration)
      var send_channel
      var ws_conn
      // Local stream after constraints are approved by the user
      var local_stream = null

      // keep track of some negotiation state to prevent races and errors
      var callCreateTriggered = false
      var makingOffer = false
      var isSettingRemoteAnswerPending = false

      const $ = (id) => document.getElementById(id)

      function onConnectClicked() {
        if ($('peer-connect-button').value == 'Disconnect') {
          resetState()
          return
        }

        var id = $('peer-connect').value
        if (id == '') {
          alert('Peer id must be filled out')
          return
        }

        ws_conn.send('SESSION ' + id)
        $('peer-connect-button').value = 'Disconnect'
      }

      function onTextKeyPress(e) {
        e = e ? e : window.event
        if (e.code == 'Enter') {
          onConnectClicked()
          return false
        }
        return true
      }

      function resetState() {
        // This will call onServerClose()
        ws_conn.close()
      }

      function handleIncomingError(error) {
        setError('ERROR: ' + error)
        resetState()
      }

      function setStatus(text) {
        console.log(text)
        var span = $('status')
        // Don't set the status if it already contains an error
        if (!span.classList.contains('error')) span.textContent = text
      }

      function setError(text) {
        console.error(text)
        var span = $('status')
        span.textContent = text
        span.classList.add('error')
      }

      window.onload = function websocketServerConnect() {
        connect_attempts++
        if (connect_attempts > 3) {
          setError('Too many connection attempts, aborting. Refresh page to try again')
          return
        }
        // Clear errors in the status span
        var span = $('status')
        span.classList.remove('error')
        span.textContent = ''
        // Populate constraints
        var textarea = $('constraints')
        if (textarea.value == '') textarea.value = JSON.stringify(default_constraints)
        // Fetch the peer id to use
        var peer_id = default_peer_id || Math.floor(Math.random() * (9000 - 10) + 10).toString()
        ws_protocol = ws_protocol || 'ws'
        ws_port = ws_port || '8443'
        if (window.location.protocol.startsWith('file')) {
          ws_server = ws_server || '127.0.0.1'
        } else if (window.location.protocol.startsWith('http')) {
          ws_server = ws_server || window.location.hostname
        } else {
          throw new Error("Don't know how to connect to the signalling server with uri" + window.location)
        }
        var ws_url = ws_protocol + '://' + ws_server + ':' + ws_port
        setStatus('Connecting to server ' + ws_url)
        ws_conn = new WebSocket(ws_url)
        /* When connected, immediately register with the server */
        ws_conn.addEventListener('open', () => {
          $('peer-id').textContent = peer_id
          ws_conn.send('HELLO ' + peer_id)
          setStatus('Registering with server')
          $('peer-connect-button').value = 'Connect'
          // Reset connection attempts because we connected successfully
          connect_attempts = 0
        })
        ws_conn.addEventListener('error', function onServerError() {
          setError('Unable to connect to server, did you add an exception for the certificate?')
          // Retry after 3 seconds
          window.setTimeout(websocketServerConnect, 3000)
        })
        ws_conn.addEventListener('message', async function onServerMessage(event) {
          console.log('Received ' + event.data)
          switch (event.data) {
            case 'HELLO':
              setStatus('Registered with server, waiting for call')
              return
            case 'SESSION_OK':
              setStatus('Starting negotiation')
              if ($('remote-offerer').checked) {
                ws_conn.send('OFFER_REQUEST')
                setStatus('Sent OFFER_REQUEST, waiting for offer')
                return
              }
              if (!callCreateTriggered) {
                createCall()
                setStatus('Created peer connection for call, waiting for SDP')
              }
              return
            case 'OFFER_REQUEST':
              // The peer wants us to set up and then send an offer
              if (!callCreateTriggered) createCall()
              return
            default:
              if (event.data.startsWith('ERROR')) {
                handleIncomingError(event.data)
                return
              }
              // Handle incoming JSON SDP and ICE messages
              try {
                var msg = JSON.parse(event.data)

                // Incoming JSON signals the beginning of a call
                if (!callCreateTriggered) createCall(msg)

                if (msg.sdp != null) {
                  // onIncomingSDP(msg.sdp);
                  try {
                    // An offer may come in while we are busy processing SRD(answer).
                    // In this case, we will be in "stable" by the time the offer is processed
                    // so it is safe to chain it on our Operations Chain now.
                    const readyForOffer = !makingOffer && (peer_connection.signalingState == 'stable' || isSettingRemoteAnswerPending)
                    const offerCollision = msg.sdp.type == 'offer' && !readyForOffer

                    if (offerCollision) {
                      return
                    }
                    isSettingRemoteAnswerPending = msg.sdp.type == 'answer'

                    await peer_connection.setRemoteDescription(msg.sdp)
                    setStatus('Remote SDP set')
                    isSettingRemoteAnswerPending = false
                    if (msg.sdp.type == 'offer') {
                      setStatus('Got SDP offer, waiting for getUserMedia to complete')
                      await local_stream()
                      setStatus('getUserMedia to completed, setting local description')
                      await peer_connection.setLocalDescription()
                      let desc = peer_connection.localDescription
                      console.log('Got local description: ' + JSON.stringify(desc))
                      setStatus('Sending SDP ' + desc.type)
                      ws_conn.send(JSON.stringify({ sdp: desc }))
                      if (peer_connection.iceConnectionState == 'connected') {
                        setStatus('SDP ' + desc.type + ' sent, ICE connected, all looks OK')
                      }
                    }
                  } catch (err) {
                    handleIncomingError(err)
                  }
                } else if (msg.ice != null) {
                  // onIncomingICE(msg.ice);
                  var candidate = new RTCIceCandidate(msg.ice)
                  peer_connection.addIceCandidate(candidate).catch(setError)
                } else {
                  handleIncomingError('Unknown incoming JSON: ' + msg)
                }
              } catch (e) {
                if (e instanceof SyntaxError) {
                  handleIncomingError('Error parsing incoming JSON: ' + event.data)
                } else {
                  handleIncomingError('Unknown error parsing response: ' + event.data)
                }
                return
              }
          }
        })
        ws_conn.addEventListener('close', async function onServerClose() {
          setStatus('Disconnected from server')

          // Release the webcam and mic
          if (local_stream) {
            const stream = await local_stream()
            if (stream) {
              stream.getTracks().forEach(function (track) {
                track.stop()
              })
            }
            local_stream = null
          }

          // Remove all video players
          $('video').innerHTML = ''

          if (peer_connection) {
            peer_connection.close()
            peer_connection = new RTCPeerConnection(rtc_configuration)
          }
          callCreateTriggered = false

          // Reset after a second
          window.setTimeout(websocketServerConnect, 1000)
        })
      }

      const handleDataChannelOpen = (event) => {
        console.log('dataChannel.OnOpen', event)
      }

      const handleDataChannelMessageReceived = (event) => {
        console.log('dataChannel.OnMessage:', event, event.data.type)

        setStatus('Received data channel message')
        if (typeof event.data === 'string' || event.data instanceof String) {
          console.log('Incoming string message: ' + event.data)
          var textarea = $('text')
          textarea.value = textarea.value + '\n' + event.data
        } else {
          console.log('Incoming data message')
        }
        send_channel.send('Hi! (from browser)')
      }

      const handleDataChannelError = (error) => {
        console.log('dataChannel.OnError:', error)
      }

      const handleDataChannelClose = (event) => {
        console.log('dataChannel.OnClose', event)
      }

      function onDataChannel(event) {
        setStatus('Data channel created')
        let receiveChannel = event.channel
        receiveChannel.onopen = handleDataChannelOpen
        receiveChannel.onmessage = handleDataChannelMessageReceived
        receiveChannel.onerror = handleDataChannelError
        receiveChannel.onclose = handleDataChannelClose
      }

      async function createCall() {
        callCreateTriggered = true
        console.log('Configuring RTCPeerConnection')
        send_channel = peer_connection.createDataChannel('label', null)
        send_channel.onopen = handleDataChannelOpen
        send_channel.onmessage = handleDataChannelMessageReceived
        send_channel.onerror = handleDataChannelError
        send_channel.onclose = handleDataChannelClose
        peer_connection.ondatachannel = onDataChannel

        peer_connection.ontrack = ({ streams }) => {
          console.log('ontrack triggered')

          // var videoElem = getVideoElement();
          var div = $('video')
          var videoElem = document.createElement('video')
          videoElem.textContent = "Your browser doesn't support video"
          videoElem.autoplay = true
          videoElem.playsinline = true
          div.appendChild(videoElem)

          if (event.track.kind === 'audio') videoElem.style.display = 'none'

          videoElem.srcObject = streams[0]
          videoElem.srcObject.addEventListener('mute', () => {
            console.log('track muted, hiding video element')
            videoElem.style.display = 'none'
          })
          videoElem.srcObject.addEventListener('unmute', () => {
            console.log('track unmuted, showing video element')
            videoElem.style.display = 'block'
          })
          videoElem.srcObject.addEventListener('removetrack', () => {
            console.log('track removed, removing video element')
            videoElem.remove()
          })
        }

        peer_connection.onicecandidate = (event) => {
          // We have a candidate, send it to the remote party with the
          // same uuid
          if (event.candidate == null) {
            console.log('ICE Candidate was null, done')
            return
          }
          ws_conn.send(JSON.stringify({ ice: event.candidate }))
        }
        peer_connection.oniceconnectionstatechange = () => {
          if (peer_connection.iceConnectionState == 'connected') {
            setStatus('ICE gathering complete')
          }
        }

        // let the "negotiationneeded" event trigger offer generation
        peer_connection.onnegotiationneeded = async () => {
          setStatus('Negotiation needed')
          if ($('remote-offerer').checked) return
          try {
            makingOffer = true
            await peer_connection.setLocalDescription()
            let desc = peer_connection.localDescription
            setStatus('Sending SDP ' + desc.type)
            ws_conn.send(JSON.stringify({ sdp: desc }))
          } catch (err) {
            handleIncomingError(err)
          } finally {
            makingOffer = false
          }
        }

        /* Send our video/audio to the other peer */
        local_stream = async function getLocalStream() {
          /* Send our video/audio to the other peer */
          var constraints
          var textarea = $('constraints')
          try {
            constraints = JSON.parse(textarea.value)
          } catch (e) {
            console.error(e)
            setError('ERROR parsing constraints: ' + e.message + ', using default constraints')
            constraints = default_constraints
          }
          console.log(JSON.stringify(constraints))

          // Add local stream
          if (navigator.mediaDevices.getUserMedia) {
            const stream = await navigator.mediaDevices.getUserMedia(constraints)
            console.log('Adding local stream')
            for (const track of stream.getTracks()) {
              peer_connection.addTrack(track, stream)
            }
            return stream
          } else {
            // errorUserMediaHandler();
            setError("Browser doesn't support getUserMedia!")
          }
        }

        $('peer-connect-button').value = 'Disconnect'
      }

      const getIpVersion = (ip) => (/^(\d{1,3}\.){3}\d{1,3}$/.test(ip) ? 'IPv4' : 'IPv6')
      setInterval(async () => {
        const stats = await peer_connection.getStats(null)
        var PeerConnection = null
        var DataChannels = []
        stats.forEach((report) => {
          if (report.type === 'candidate-pair') {
            if (report.state === 'succeeded') {
            } else {
              console.log('candidate-pair state:', report.state)
            }
          } else if (report.type === 'inbound-rtp') {
            report.codec = stats.get(report.codecId)
            if (report.playoutId) {
              report.playout = stats.get(report.playoutId)
            }
            if (report.remoteId) {
              report.remote = stats.get(report.remoteId)
              report.remote.codec = stats.get(report.remote.codecId)
            }
            console.log(`Inbound RTP(${report.kind}):`, report)
          } else if (report.type === 'outbound-rtp') {
            report.codec = stats.get(report.codecId)
            report.mediaSource = stats.get(report.mediaSourceId)
            if (report.remoteId) {
              report.remote = stats.get(report.remoteId)
              report.remote.codec = stats.get(report.remote.codecId)
            }
            console.log(`Outbound RTP(${report.kind}):`, report)
          } else if (report.type === 'transport') {
            report.localCertificate = stats.get(report.localCertificateId)
            report.remoteCertificate = stats.get(report.remoteCertificateId)
            report.selectedCandidatePair = stats.get(report.selectedCandidatePairId)
            report.selectedCandidatePair.remoteCandidate = stats.get(report.selectedCandidatePair.remoteCandidateId)
            report.selectedCandidatePair.remoteCandidate.ipVersion = getIpVersion(report.selectedCandidatePair.remoteCandidate.ip)
            report.selectedCandidatePair.localCandidate = stats.get(report.selectedCandidatePair.localCandidateId)
            report.selectedCandidatePair.localCandidate.ipVersion = getIpVersion(report.selectedCandidatePair.localCandidate.ip)
            console.log('Transport:', report)
          } else if (report.type === 'peer-connection') {
            PeerConnection = report
          } else if (report.type === 'data-channel') {
            DataChannels.push(report)
          } else {
            if (report.type !== 'local-candidate' && report.type !== 'remote-candidate' && report.type !== 'remote-inbound-rtp' && report.type !== 'remote-outbound-rtp' && report.type !== 'media-source' && report.type !== 'media-playout' && report.type !== 'certificate' && report.type !== 'codec') {
              console.log('unknown type:', report.type)
            }
          }
        })
        PeerConnection.dataChannels = DataChannels
        console.log('Peer Connection:', PeerConnection)
      }, 10000)
    </script>
  </head>

  <body>
    <div id="video"></div>
    <div>Status: <span id="status">unknown</span></div>
    <div><textarea id="text" cols="40" rows="4"></textarea></div>
    <br />
    <div>
      <label for="peer-connect">Enter peer id</label>
      <input id="peer-connect" type="text" name="text" onkeypress="onTextKeyPress();" required />
      <input id="peer-connect-button" onclick="onConnectClicked();" type="button" value="Connect" />
      <!-- Request the peer to send the offer by sending the OFFER_REQUEST message.
        Same as the --remote-offerer flag in the sendrecv C example -->
      <input id="remote-offerer" type="checkbox" autocomplete="off" /><span>Remote offerer</span>
    </div>

    <div>Our id is <b id="peer-id">unknown</b></div>
    <br />
    <div>
      <div>getUserMedia constraints being used:</div>
      <div><textarea id="constraints" cols="40" rows="4"></textarea></div>
    </div>
  </body>
</html>
